<?xml version="1.0" encoding="UTF-8"?>
<grammar ns="http://csrc.nist.gov/ns/oscal/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <!--
    We can have a catalog, or we can have only declarations for catalogs, or we can have a framework
    (which is kind of a 'catalog mockup' format)
  -->
  <start>
    <choice>
      <ref name="catalog"/>
      <ref name="declarations"/>
      <ref name="framework"/>
    </choice>
  </start>
  <define name="catalog-contents">
    <ref name="title"/>
    <optional>
      <ref name="declarations"/>
    </optional>
    <zeroOrMore>
      <choice>
        <ref name="section"/>
        <ref name="group"/>
        <ref name="control"/>
      </choice>
    </zeroOrMore>
    <optional>
      <ref name="references"/>
    </optional>
  </define>
  <define name="framework-contents">
    <ref name="title"/>
    <optional>
      <ref name="declarations"/>
    </optional>
    <zeroOrMore>
      <choice>
        <ref name="section"/>
        <ref name="category"/>
        <ref name="item"/>
      </choice>
    </zeroOrMore>
    <optional>
      <ref name="references"/>
    </optional>
  </define>
  <!-- 'worksheet' is just an alias for 'framework' for now -->
  <define name="worksheet-contents">
    <ref name="title"/>
    <optional>
      <ref name="declarations"/>
    </optional>
    <zeroOrMore>
      <choice>
        <ref name="section"/>
        <ref name="category"/>
        <ref name="item"/>
      </choice>
    </zeroOrMore>
    <optional>
      <ref name="references"/>
    </optional>
  </define>
  <define name="catalog">
    <element name="catalog">
      <ref name="catalog-contents"/>
    </element>
  </define>
  <define name="framework">
    <element name="framework">
      <ref name="idAttr"/>
      <ref name="optionalClass"/>
      <ref name="framework-contents"/>
    </element>
  </define>
  <define name="worksheet">
    <element name="worksheet">
      <ref name="idAttr"/>
      <ref name="optionalClass"/>
      <ref name="worksheet-contents"/>
    </element>
  </define>
  <!--
    'group' is the element name as it appears in both frameworks, and catalogs
    but they group different things
  -->
  <define name="category">
    <element name="group">
      <ref name="idAttr"/>
      <ref name="optionalClass"/>
      <optional>
        <ref name="title"/>
      </optional>
      <zeroOrMore>
        <choice>
          <ref name="prop"/>
          <ref name="link"/>
          <ref name="prose"/>
        </choice>
      </zeroOrMore>
      <choice>
        <oneOrMore>
          <ref name="category"/>
        </oneOrMore>
        <oneOrMore>
          <ref name="item"/>
        </oneOrMore>
      </choice>
    </element>
  </define>
  <define name="item">
    <element name="component">
      <ref name="idAttr"/>
      <ref name="optionalClass"/>
      <optional>
        <ref name="title"/>
      </optional>
      <zeroOrMore>
        <choice>
          <ref name="param"/>
          <ref name="prop"/>
          <ref name="link"/>
          <ref name="prose"/>
          <ref name="part"/>
        </choice>
      </zeroOrMore>
      <zeroOrMore>
        <ref name="item"/>
      </zeroOrMore>
    </element>
  </define>
  <!-- an overlay - a framework whose structure matches the catalog? -->
  <!--
    frameworks contain categories or items
    categories contain categories or items
    items contain title?, prop*, p*, link*
    strict governance over item/link/@rel
    declarations too :-)
    validation can ensure that framework links are scoped
    corresponding with catalogs/controls included in the profile
  -->
  <!--
    declarations includes declarations for control types, parameters (names/types),
    authorities (source data for transclusion etc. etc.)
  -->
  <define name="declarations">
    <element name="declarations">
      <optional>
        <ref name="hrefAttr"/>
      </optional>
      <ref name="decls"/>
    </element>
  </define>
  <define name="decls">
    <zeroOrMore>
      <choice>
        <ref name="parameter_decl"/>
        <ref name="property_decl"/>
        <ref name="part_decl"/>
        <ref name="para_decl"/>
        <ref name="link_decl"/>
      </choice>
    </zeroOrMore>
  </define>
  <!--
    parameter declarations expose names and default values for parameters within the control type
    XXX not implemented: for now, parameters are declared implicitly (i.e. in use)
    We can add this (w/ support for it) when we wish to constrain them at the OSCAL layer
  -->
  <define name="parameter_decl">
    <empty/>
  </define>
  <!--
    parameter_decl =
    element declare-param { requiredClass, contextAttr, singleton?, desc, \default? }
  -->
  <!-- property may contain only id, only regex, both id and regex, or (sequence of) values -->
  <define name="property_decl">
    <element name="declare-prop">
      <ref name="requiredClass"/>
      <ref name="contextAttr"/>
      <optional>
        <ref name="singleton"/>
      </optional>
      <optional>
        <ref name="required"/>
      </optional>
      <optional>
        <element name="identifier">
          <empty/>
        </element>
      </optional>
      <choice>
        <ref name="regex"/>
        <zeroOrMore>
          <ref name="value"/>
        </zeroOrMore>
      </choice>
    </element>
  </define>
  <!--
    part declaration
    add 'purpose', 'guidance' etc.
  -->
  <define name="part_decl">
    <element name="declare-part">
      <ref name="requiredClass"/>
      <ref name="contextAttr"/>
      <optional>
        <ref name="singleton"/>
      </optional>
      <optional>
        <ref name="required"/>
      </optional>
    </element>
  </define>
  <!-- paragraph declaration -->
  <define name="para_decl">
    <element name="declare-p">
      <ref name="requiredClass"/>
      <ref name="contextAttr"/>
      <optional>
        <ref name="singleton"/>
      </optional>
      <optional>
        <ref name="required"/>
      </optional>
    </element>
  </define>
  <!-- link declaration -->
  <define name="link_decl">
    <element name="declare-link">
      <ref name="relAttr"/>
      <ref name="contextAttr"/>
      <optional>
        <ref name="singleton"/>
      </optional>
      <optional>
        <ref name="required"/>
      </optional>
    </element>
  </define>
  <define name="singleton">
    <element name="singleton">
      <empty/>
    </element>
  </define>
  <define name="required">
    <element name="required">
      <empty/>
    </element>
  </define>
  <!--
    on 'property and possibly 'parameter',
    element limit { requiredClass, text } w/ @type= upper-bound-inclusive, lower-bound-exclusive, (w/ inclusive/exclusive etc.)
  -->
  <define name="regex">
    <element name="regex">
      <text/>
    </element>
  </define>
  <define name="value">
    <element name="value">
      <optional>
        <attribute name="xml:space">
          <value>preserve</value>
        </attribute>
      </optional>
      <zeroOrMore>
        <choice>
          <ref name="inherit"/>
          <ref name="autonum"/>
          <text/>
        </choice>
      </zeroOrMore>
    </element>
  </define>
  <define name="inherit">
    <element name="inherit">
      <optional>
        <attribute name="from"/>
      </optional>
      <text/>
    </element>
  </define>
  <define name="autonum">
    <element name="autonum">
      <text/>
    </element>
  </define>
  <!--
    done with declarations - controls, subcontrols and groups are not declared
    (constrained) at the OSCAL layer so they don't get declaration elements.
  -->
  <!-- Now for the contents of the OSCAL doc proper ... -->
  <define name="section">
    <element name="section">
      <ref name="idAttr"/>
      <ref name="optionalClass"/>
      <ref name="title"/>
      <ref name="prose"/>
      <zeroOrMore>
        <choice>
          <ref name="section"/>
          <ref name="group"/>
        </choice>
      </zeroOrMore>
      <optional>
        <ref name="references"/>
      </optional>
    </element>
  </define>
  <!--
    groups may contain more groups, controls or subcontrols
    But controls should not appear in controls (even grouped)
    And subcontrols must not appear without control ancestors
    ... these constraints validated w/ Schematron
  -->
  <define name="group">
    <element name="group">
      <ref name="idAttr"/>
      <ref name="optionalClass"/>
      <optional>
        <ref name="title"/>
      </optional>
      <ref name="control-components"/>
      <oneOrMore>
        <choice>
          <ref name="group"/>
          <ref name="control"/>
        </choice>
      </oneOrMore>
      <optional>
        <ref name="references"/>
      </optional>
    </element>
  </define>
  <!-- note prose is not included in control-components, unlike item pattern ('component' element) -->
  <define name="control-components">
    <zeroOrMore>
      <choice>
        <ref name="prop"/>
        <ref name="anyKindofPart"/>
        <ref name="link"/>
        <ref name="param"/>
      </choice>
    </zeroOrMore>
  </define>
  <define name="control">
    <element name="control">
      <ref name="idAttr"/>
      <ref name="optionalClass"/>
      <optional>
        <ref name="title"/>
      </optional>
      <zeroOrMore>
        <choice>
          <ref name="control-components"/>
          <ref name="subcontrol"/>
        </choice>
      </zeroOrMore>
      <optional>
        <ref name="references"/>
      </optional>
    </element>
  </define>
  <define name="subcontrol">
    <element name="subcontrol">
      <ref name="idAttr"/>
      <ref name="optionalClass"/>
      <optional>
        <ref name="title"/>
      </optional>
      <ref name="control-components"/>
      <optional>
        <ref name="references"/>
      </optional>
    </element>
  </define>
  <!-- Add 'semantic' part types: purpose, guidance, decision, information, remarks (etc) -->
  <define name="anyKindofPart">
    <zeroOrMore>
      <ref name="part"/>
    </zeroOrMore>
  </define>
  <!--
    see utility.xq for analytic breakdown of part types
    so far: description, guidance
  -->
  <!-- parts are addressable like controls, but can also have prose content -->
  <define name="part">
    <element name="part">
      <ref name="idAttr"/>
      <ref name="optionalClass"/>
      <optional>
        <ref name="title"/>
      </optional>
      <zeroOrMore>
        <choice>
          <ref name="prose"/>
          <ref name="control-components"/>
        </choice>
      </zeroOrMore>
    </element>
  </define>
  <define name="title">
    <element name="title">
      <zeroOrMore>
        <choice>
          <text/>
          <ref name="q"/>
        </choice>
      </zeroOrMore>
    </element>
  </define>
  <define name="link">
    <element name="link">
      <ref name="relAttr"/>
      <ref name="hrefAttr"/>
      <ref name="mix"/>
    </element>
  </define>
  <!--
    param is like its declaration, but simpler
    permits bindings to assign and select elements w/in controls
    i.e. local override of a default assignment in a parameter declaration
    or on-the-fly declaration of new parameters for a control
    (since params are not currently required to be declared
  -->
  <define name="desc">
    <element name="desc">
      <ref name="mix"/>
    </element>
  </define>
  <define name="param">
    <element name="param">
      <ref name="idAttr"/>
      <ref name="optionalClass"/>
      <ref name="desc"/>
      <ref name="paramValue"/>
    </element>
  </define>
  <define name="paramValue">
    <element name="value">
      <text/>
    </element>
  </define>
  <define name="prop">
    <element name="prop">
      <ref name="requiredClass"/>
      <text/>
    </element>
  </define>
  <!--
    syntax sugar for part[@class='purpose'] for "Objective/s" etc.
    purpose =
      element purpose {
        prose }
  -->
  <!--
    syntax sugar for part[@class='guidance'] for "Supplemental Guidance" etc.
    guidance =
      element guidance {
        prose }
  -->
  <!--
    syntax sugar for part[@class='decision']
    decision =
      element decision {
        prose }
  -->
  <!--
    syntax sugar for part[@class='information'], other-info, etc.
    information =
      element information {
        prose }
  -->
  <!--
    syntax sugar for part[@class='remarks']
    remarks =
      element remarks {
        prose }
  -->
  <define name="prose">
    <zeroOrMore>
      <choice>
        <ref name="ul"/>
        <ref name="ol"/>
        <ref name="p"/>
        <ref name="pre"/>
      </choice>
    </zeroOrMore>
  </define>
  <define name="references">
    <element name="references">
      <oneOrMore>
        <ref name="ref"/>
      </oneOrMore>
    </element>
  </define>
  <!-- JATS-like references -->
  <define name="ref">
    <element name="ref">
      <ref name="idAttr"/>
      <zeroOrMore>
        <choice>
          <ref name="std"/>
          <ref name="citation"/>
          <ref name="prose"/>
        </choice>
      </zeroOrMore>
    </element>
  </define>
  <!-- analogous to JATS mixed-citation[@citation-type='standard'] or equivalent -->
  <define name="std">
    <element name="std">
      <optional>
        <attribute name="href">
          <data type="anyURI"/>
        </attribute>
      </optional>
      <zeroOrMore>
        <choice>
          <ref name="mix"/>
          <ref name="xref"/>
        </choice>
      </zeroOrMore>
    </element>
  </define>
  <!-- analogous to JATS mixed-citation -->
  <define name="citation">
    <element name="citation">
      <optional>
        <attribute name="href">
          <data type="anyURI"/>
        </attribute>
      </optional>
      <zeroOrMore>
        <choice>
          <ref name="mix"/>
          <ref name="xref"/>
        </choice>
      </zeroOrMore>
    </element>
  </define>
  <!-- We can map more html in if/as needed -->
  <define name="p">
    <element name="p">
      <ref name="idAttr"/>
      <ref name="optionalClass"/>
      <ref name="whatnot"/>
    </element>
  </define>
  <define name="pre">
    <element name="pre">
      <ref name="idAttr"/>
      <zeroOrMore>
        <choice>
          <ref name="mix"/>
          <ref name="xref"/>
        </choice>
      </zeroOrMore>
    </element>
  </define>
  <define name="ol">
    <element name="ol">
      <oneOrMore>
        <element name="li">
          <ref name="idAttr"/>
          <ref name="optionalClass"/>
          <zeroOrMore>
            <choice>
              <ref name="whatnot"/>
              <ref name="ol"/>
              <ref name="ul"/>
            </choice>
          </zeroOrMore>
        </element>
      </oneOrMore>
    </element>
  </define>
  <define name="ul">
    <element name="ul">
      <oneOrMore>
        <element name="li">
          <ref name="idAttr"/>
          <ref name="optionalClass"/>
          <zeroOrMore>
            <choice>
              <ref name="whatnot"/>
              <ref name="ol"/>
              <ref name="ul"/>
            </choice>
          </zeroOrMore>
        </element>
      </oneOrMore>
    </element>
  </define>
  <!-- whatnot includes 'semantical' elements along with the inline mix -->
  <define name="whatnot">
    <zeroOrMore>
      <choice>
        <ref name="semantical"/>
        <ref name="mix"/>
        <ref name="xref"/>
      </choice>
    </zeroOrMore>
  </define>
  <!-- note mix does not include anchors, which must be included separately -->
  <define name="mix">
    <zeroOrMore>
      <choice>
        <ref name="inlines"/>
        <text/>
      </choice>
    </zeroOrMore>
  </define>
  <!-- declaring as zeroOrMore/choice avoids XSD substitution group -->
  <define name="inlines">
    <zeroOrMore>
      <choice>
        <ref name="q"/>
        <ref name="code"/>
        <ref name="em"/>
        <ref name="i"/>
        <ref name="b"/>
        <ref name="sub"/>
        <ref name="sup"/>
        <ref name="span"/>
      </choice>
    </zeroOrMore>
  </define>
  <define name="q">
    <element name="q">
      <zeroOrMore>
        <choice>
          <ref name="i"/>
          <ref name="b"/>
          <ref name="sub"/>
          <ref name="sup"/>
          <text/>
        </choice>
      </zeroOrMore>
    </element>
  </define>
  <!-- A bit of code (perhaps capable of evaluation in the correct context) -->
  <define name="code">
    <element name="code">
      <ref name="optionalClass"/>
      <ref name="mix"/>
    </element>
  </define>
  <define name="em">
    <element name="em">
      <ref name="optionalClass"/>
      <zeroOrMore>
        <choice>
          <ref name="mix"/>
          <ref name="xref"/>
        </choice>
      </zeroOrMore>
    </element>
  </define>
  <define name="i">
    <element name="i">
      <ref name="optionalClass"/>
      <zeroOrMore>
        <choice>
          <ref name="mix"/>
          <ref name="xref"/>
        </choice>
      </zeroOrMore>
    </element>
  </define>
  <define name="b">
    <element name="b">
      <ref name="optionalClass"/>
      <zeroOrMore>
        <choice>
          <ref name="mix"/>
          <ref name="xref"/>
        </choice>
      </zeroOrMore>
    </element>
  </define>
  <define name="sub">
    <element name="sub">
      <ref name="optionalClass"/>
      <text/>
    </element>
  </define>
  <define name="sup">
    <element name="sup">
      <ref name="optionalClass"/>
      <text/>
    </element>
  </define>
  <!-- An arbitrary span -->
  <define name="span">
    <element name="span">
      <ref name="optionalClass"/>
      <zeroOrMore>
        <choice>
          <ref name="mix"/>
          <ref name="xref"/>
        </choice>
      </zeroOrMore>
    </element>
  </define>
  <!-- Using HTML for this -->
  <define name="xref">
    <element name="a">
      <optional>
        <attribute name="href"/>
      </optional>
      <zeroOrMore>
        <choice>
          <ref name="q"/>
          <ref name="code"/>
          <element name="em">
            <ref name="optionalClass"/>
            <text/>
          </element>
          <text/>
        </choice>
      </zeroOrMore>
    </element>
  </define>
  <!-- not html! -->
  <!-- declaring as zeroOrMore/choice avoids XSD substitution group -->
  <define name="semantical">
    <zeroOrMore>
      <choice>
        <ref name="withdrawn"/>
        <ref name="assign"/>
        <ref name="select"/>
      </choice>
    </zeroOrMore>
  </define>
  <!-- A placeholder status report typically with a cross-reference -->
  <define name="withdrawn">
    <element name="withdrawn">
      <zeroOrMore>
        <choice>
          <ref name="inlines"/>
          <text/>
        </choice>
      </zeroOrMore>
    </element>
  </define>
  <!--
    A value to be assigned by responder via parameter
    (a parameter must be available)
  -->
  <define name="assign">
    <element name="insert">
      <ref name="idAttr"/>
      <attribute name="param-id">
        <data type="IDREF"/>
      </attribute>
    </element>
  </define>
  <!-- A selection to be made by responder - tbd -->
  <define name="select">
    <empty/>
  </define>
  <!-- select = element select { idAttr, choice* } -->
  <!--
    Within a selection, a choice - tbd
    unlike 'value', choice may have inline stuff as well as 'assign' elements
    choice = element choice { (assign | mix)* }
  -->
  <!-- IDs are required everywhere for now -->
  <define name="idAttr">
    <optional>
      <attribute name="id">
        <data type="ID"/>
      </attribute>
    </optional>
  </define>
  <!--
    we used to distinguish btw @type and @name the latter for components
    now we overload 'class' every which way
  -->
  <define name="requiredClass">
    <attribute name="class"/>
  </define>
  <define name="optionalClass">
    <optional>
      <attribute name="class"/>
    </optional>
  </define>
  <define name="contextAttr">
    <attribute name="context"/>
  </define>
  <define name="relAttr">
    <optional>
      <attribute name="rel"/>
    </optional>
  </define>
  <define name="hrefAttr">
    <optional>
      <attribute name="href"/>
    </optional>
  </define>
</grammar>
<!-- requiredClass = attribute name { xsd:NCName } -->
