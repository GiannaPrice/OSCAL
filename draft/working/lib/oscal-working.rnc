default namespace = "http://scap.nist.gov/schema/oscal"

# We can have a catalog, or we can have only declarations for catalogs
start = (catalog | declarations)

# start = element oscal-catalog { declarations, catalog } 
# have initial sections
# declare   - declares local parameters and settings including constraints on controls
#             (enumerated values for properties, regexes and what not)
# also declares bindings to authorities (e.g. sources for transclusion/comparison)?

catalog = element catalog { title, declarations?, section*, (group+ | control+), section*, references? }

# do we want a 'runtime' element for runtime bindings? such as parameters

# declarations includes declarations for control types, parameters (names/types),
# authorities (source data for transclusion etc. etc.)
declarations = ( element declarations { attribute href { text }?, decls } )

decls = (parameter | property | statement)*

# parameter declarations expose names and default values for parameters within the control type
parameter   = element parameter {
  nameAttr, contextAttr, (regex | value | choice+)? }

# property may contain only id, only regex, both id and regex, or (sequence of) values
property =
  element property {
    nameAttr, contextAttr, required?,
    ( ((element identifier { empty }?, (regex | autonum )? ) |
        value* ) )
  }

# on 'property and possibly 'parameter',
# element limit { nameAttr, text } w/ @type= upper-bound-inclusive, lower-bound-exclusive, (w/ inclusive/exclusive etc.)
  
regex = element regex { text }
value = element value { ( \inherit | autonum | text )* }
\inherit = element inherit { attribute from { text }?, text }
autonum = element autonum { text }

statement =
  element statement { nameAttr, contextAttr, required? }

required = element required { empty }

# now for elements themselves

group = element group {
  idAttr, typeAttr,
  title?, prop*, anyKindofStatement*, (group* | control*), section*, references? }

section = element div { idAttr, typeAttr,
  title, prose, section*, references? }

control =
  element control {
    idAttr, typeAttr,
    param*, title?, prop*, plug*,
    anyKindofStatement*,
    subcontrol*,
    references?
  }

subcontrol =
  element enhancement {
    idAttr, typeAttr,
    param*, title?, prop*,
    anyKindofStatement*,
    subcontrol*
  }

title = element title { (text | q)* }

# param is like its declaration, but simpler
# permits bindings to assign and select elements w/in controls
# i.e. local override of a default assignment in a parameter declaration
# or on-the-fly declaration of new parameters for a control
# (since params are not currently required to be declared

param   = element param { idAttr, nameAttr, mix }

prop =
  element prop {
    nameAttr,
    whatnot
  }
# on prop, not(@name = ../(* except current())/@name)

plug = empty

# plug is like prop, except it has a type instead of a role (type is not required to be unique)
#plug =
#  element plug {
#   typeAttr,
#   whatnot
# }

desc = element desc { prose }

# stmt is a bit of controlled prose: its title is implicit in its name
# e.g. stmt[@name='objectives'] might be displayed with title "Objectives:"

#anyKindofStatement = ( stmt | desc | purpose | guidance | information | remarks )
anyKindofStatement = stmt

stmt =
  element stmt {
    nameAttr?,
    prose }

# syntax sugar for stmt[@role='purpose'] for "Objective/s" etc.
purpose =
  element purpose {
    prose }

# syntax sugar for stmt[@role='guidance'] for "Supplemental Guidance" etc.
guidance =
  element guidance {
    prose }

# syntax sugar for stmt[@role='decision']
decision =
  element decision {
    prose }

# syntax sugar for stmt[@role='information'], other-info, etc.
information =
  element information {
    prose }


# syntax sugar for stmt[@role='remarks']
remarks =
  element remarks {
    prose }


prose = ( ul | ol | p )*

# cluster = element cluster { control+ | prop+ | ref+ }
# on group, not(*/@name != */@name) ie all names must be the same

references = element references { ref+ }

ref = element ref { idAttr, (std | citation)* }
# add mixed-citation or equivalent

std =  element std {
         attribute href { xsd:anyURI }?,
         mix
  }

citation =  element citation {
         attribute href { xsd:anyURI }?,
         mix
  }

p =
  element p { idAttr, (semantical | mix)* }

ol =
  element ol {
    element li { whatnot }+
  }

ul =
  element ul {
    element li { whatnot }+
  }

idAttr      = attribute id { xsd:ID }?

nameAttr    = attribute role { text }?

typeAttr    = attribute type { text }?

contextAttr = attribute context { text }

#nameAttr = attribute name { xsd:NCName }

# html!
whatnot = (
  semantical | ol | ul | mix )*

mix = (inlines | text)*

inlines = (  q | code | element em { text } | element xref { attribute href { text }?, text } )

q = element q { text }

# A bit of code (perhaps capable of evaluation in the correct context)
code = element code { attribute type { text }?, mix }

# not html!
semantical = ( withdrawn | assign | select )

# A placeholder status report typically with a cross-reference
withdrawn = element withdrawn { (inlines | text)* }

# A value to be assigned by responder, possibly via a param (parameter) or parameter declaration
assign = element assign { paramAttr?, mix }

# A selection to be made by responder
select = element select { paramAttr?, choice* }

# Within a selection, a choice
# unlike 'value', choice may have inline stuff as well as 'assign' elements
choice = element choice { (assign | mix)* }


paramAttr = attribute use { text }?
