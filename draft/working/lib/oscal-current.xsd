<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" targetNamespace="http://scap.nist.gov/schema/oscal" xmlns:oscal="http://scap.nist.gov/schema/oscal">
  <!-- We can have a catalog, or we can have only declarations for catalogs -->
  <!-- Also we have an alias for 'catalog', namely 'collection', used for ad-hoc collections of controls -->
  <!--
    start = element oscal-catalog { declarations, catalog } 
    have initial sections
    declare   - declares local parameters and settings including constraints on controls
                (enumerated values for properties, regexes and what not)
    also declares bindings to authorities (e.g. sources for transclusion/comparison)?
  -->
  <!-- keeping these together until we have differentiating requirements -->
  <xs:complexType name="collection-contents">
    <xs:sequence>
      <xs:element ref="oscal:title"/>
      <xs:element minOccurs="0" ref="oscal:declarations"/>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="oscal:div"/>
      <xs:choice>
        <xs:element maxOccurs="unbounded" ref="oscal:group"/>
        <xs:element maxOccurs="unbounded" ref="oscal:control"/>
      </xs:choice>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="oscal:div"/>
      <xs:element minOccurs="0" ref="oscal:references"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="catalog" type="oscal:collection-contents"/>
  <xs:element name="collection" type="oscal:collection-contents"/>
  <!--
    declarations includes declarations for control types, parameters (names/types),
    authorities (source data for transclusion etc. etc.)
  -->
  <xs:element name="declarations">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="oscal:decls">
          <xs:attribute name="href"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:complexType name="decls">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element ref="oscal:parameter"/>
      <xs:element ref="oscal:property"/>
      <xs:element ref="oscal:statement"/>
      <xs:element ref="oscal:feature"/>
    </xs:choice>
  </xs:complexType>
  <!-- parameter declarations expose names and default values for parameters within the control type -->
  <xs:element name="parameter">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" ref="oscal:singleton"/>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="oscal:choice"/>
      </xs:sequence>
      <xs:attributeGroup ref="oscal:nameAttr"/>
      <xs:attributeGroup ref="oscal:contextAttr"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="singleton">
    <xs:complexType/>
  </xs:element>
  <!-- property may contain only id, only regex, both id and regex, or (sequence of) values -->
  <xs:element name="property">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" ref="oscal:singleton"/>
        <xs:element minOccurs="0" ref="oscal:required"/>
        <xs:element minOccurs="0" ref="oscal:identifier"/>
        <xs:choice>
          <xs:element ref="oscal:regex"/>
          <xs:element minOccurs="0" maxOccurs="unbounded" ref="oscal:value"/>
        </xs:choice>
      </xs:sequence>
      <xs:attributeGroup ref="oscal:nameAttr"/>
      <xs:attributeGroup ref="oscal:contextAttr"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="identifier">
    <xs:complexType/>
  </xs:element>
  <!--
    on 'property and possibly 'parameter',
    element limit { nameAttr, text } w/ @type= upper-bound-inclusive, lower-bound-exclusive, (w/ inclusive/exclusive etc.)
  -->
  <xs:element name="regex" type="xs:string"/>
  <xs:element name="value">
    <xs:complexType mixed="true">
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="oscal:inherit"/>
        <xs:element ref="oscal:autonum"/>
      </xs:choice>
    </xs:complexType>
  </xs:element>
  <xs:element name="inherit">
    <xs:complexType mixed="true">
      <xs:attribute name="from"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="autonum" type="xs:string"/>
  <!-- statement declaration -->
  <xs:element name="statement">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" ref="oscal:singleton"/>
        <xs:element minOccurs="0" ref="oscal:required"/>
      </xs:sequence>
      <xs:attributeGroup ref="oscal:nameAttr"/>
      <xs:attributeGroup ref="oscal:contextAttr"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="required">
    <xs:complexType/>
  </xs:element>
  <!-- feature declaration -->
  <xs:element name="feature">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" ref="oscal:singleton"/>
        <xs:element minOccurs="0" ref="oscal:required"/>
      </xs:sequence>
      <xs:attributeGroup ref="oscal:nameAttr"/>
      <xs:attributeGroup ref="oscal:contextAttr"/>
    </xs:complexType>
  </xs:element>
  <!--
    done with declarations - controls, subcontrols and groups are not declared
    (constrained) at the OSCAL layer so they don't get declaration elements.
  -->
  <!-- Now for the contents of the OSCAL doc proper ... -->
  <!--
    groups may contain more groups, controls or subcontrols
    But controls should not appear in controls (even grouped)
    And subcontrols must not appear without control ancestors
    ... these constraints validated w/ Schematron
  -->
  <xs:element name="group">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" ref="oscal:title"/>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="oscal:prop"/>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="oscal:anyKindofStatement"/>
        <xs:choice>
          <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:element ref="oscal:group"/>
            <xs:element ref="oscal:div"/>
          </xs:choice>
          <xs:element minOccurs="0" maxOccurs="unbounded" ref="oscal:control"/>
          <xs:element minOccurs="0" maxOccurs="unbounded" ref="oscal:subcontrol"/>
          <xs:element minOccurs="0" maxOccurs="unbounded" ref="oscal:feat"/>
        </xs:choice>
      </xs:sequence>
      <xs:attributeGroup ref="oscal:idAttr"/>
      <xs:attributeGroup ref="oscal:typeAttr"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="div">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="oscal:title"/>
        <xs:group ref="oscal:prose"/>
        <xs:choice minOccurs="0" maxOccurs="unbounded">
          <xs:element ref="oscal:div"/>
          <xs:element ref="oscal:group"/>
        </xs:choice>
        <xs:element minOccurs="0" ref="oscal:references"/>
      </xs:sequence>
      <xs:attributeGroup ref="oscal:idAttr"/>
      <xs:attributeGroup ref="oscal:typeAttr"/>
    </xs:complexType>
  </xs:element>
  <!--
    For some especially loose contents it might be thinkable to permit prose in controls
    (i.e. outside of statements and properties) but we have no use case, so ...
  -->
  <xs:element name="control">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" ref="oscal:title"/>
        <xs:choice minOccurs="0" maxOccurs="unbounded">
          <xs:element ref="oscal:link"/>
          <xs:element ref="oscal:param"/>
          <xs:element ref="oscal:prop"/>
          <xs:element ref="oscal:anyKindofStatement"/>
          <xs:element ref="oscal:group"/>
          <xs:element ref="oscal:subcontrol"/>
          <xs:element ref="oscal:feat"/>
        </xs:choice>
        <xs:element minOccurs="0" ref="oscal:references"/>
      </xs:sequence>
      <xs:attributeGroup ref="oscal:idAttr"/>
      <xs:attributeGroup ref="oscal:typeAttr"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="subcontrol">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" ref="oscal:title"/>
        <xs:choice minOccurs="0" maxOccurs="unbounded">
          <xs:element ref="oscal:link"/>
          <xs:element ref="oscal:param"/>
          <xs:element ref="oscal:prop"/>
          <xs:element ref="oscal:anyKindofStatement"/>
          <xs:element ref="oscal:group"/>
          <xs:element ref="oscal:feat"/>
        </xs:choice>
      </xs:sequence>
      <xs:attributeGroup ref="oscal:idAttr"/>
      <xs:attributeGroup ref="oscal:typeAttr"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="feat">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" ref="oscal:title"/>
        <xs:choice minOccurs="0" maxOccurs="unbounded">
          <xs:element ref="oscal:link"/>
          <xs:element ref="oscal:param"/>
          <xs:element ref="oscal:prop"/>
          <xs:element ref="oscal:anyKindofStatement"/>
          <xs:element ref="oscal:group"/>
          <xs:element ref="oscal:feat"/>
        </xs:choice>
      </xs:sequence>
      <xs:attributeGroup ref="oscal:idAttr"/>
      <xs:attributeGroup ref="oscal:typeAttr"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="title">
    <xs:complexType mixed="true">
      <xs:sequence>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="oscal:q"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <!--
    param is like its declaration, but simpler
    permits bindings to assign and select elements w/in controls
    i.e. local override of a default assignment in a parameter declaration
    or on-the-fly declaration of new parameters for a control
    (since params are not currently required to be declared
  -->
  <xs:element name="link">
    <xs:complexType mixed="true">
      <xs:group ref="oscal:mix"/>
      <xs:attributeGroup ref="oscal:relAttr"/>
      <xs:attributeGroup ref="oscal:hrefAttr"/>
    </xs:complexType>
  </xs:element>
  <!-- Can't inject param values into parameter settings, okay? -->
  <xs:element name="param">
    <xs:complexType mixed="true">
      <xs:group ref="oscal:mix"/>
      <xs:attributeGroup ref="oscal:idAttr"/>
      <xs:attributeGroup ref="oscal:nameAttr"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="prop">
    <xs:complexType mixed="true">
      <xs:group ref="oscal:whatnot"/>
      <xs:attributeGroup ref="oscal:nameAttr"/>
    </xs:complexType>
  </xs:element>
  <!-- on prop, not(@name = ../(* except current())/@name) -->
  <!--
    stmt is a bit of controlled prose: its title is implicit in its name
    e.g. stmt[@name='objectives'] might be displayed with title "Objectives:"
  -->
  <!-- for harder wiring: anyKindofStatement = ( stmt | desc | purpose | guidance | information | remarks ) -->
  <xs:element name="anyKindofStatement" abstract="true">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="oscal:prose"/>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="oscal:link"/>
      </xs:sequence>
      <xs:attributeGroup ref="oscal:nameAttr"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="stmt" substitutionGroup="oscal:anyKindofStatement"/>
  <!--
    syntax sugar for stmt[@role='purpose'] for "Objective/s" etc.
    purpose =
      element purpose {
        prose }
  -->
  <!--
    syntax sugar for stmt[@role='guidance'] for "Supplemental Guidance" etc.
    guidance =
      element guidance {
        prose }
  -->
  <!--
    syntax sugar for stmt[@role='decision']
    decision =
      element decision {
        prose }
  -->
  <!--
    syntax sugar for stmt[@role='information'], other-info, etc.
    information =
      element information {
        prose }
  -->
  <!--
    syntax sugar for stmt[@role='remarks']
    remarks =
      element remarks {
        prose }
  -->
  <xs:group name="prose">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="oscal:ul"/>
        <xs:element ref="oscal:ol"/>
        <xs:element ref="oscal:p"/>
        <xs:element ref="oscal:pre"/>
      </xs:choice>
    </xs:sequence>
  </xs:group>
  <xs:element name="references">
    <xs:complexType>
      <xs:sequence>
        <xs:element maxOccurs="unbounded" ref="oscal:ref"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <!-- JATS-like references -->
  <xs:element name="ref">
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="oscal:std"/>
        <xs:element ref="oscal:citation"/>
        <xs:group ref="oscal:prose"/>
      </xs:choice>
      <xs:attributeGroup ref="oscal:idAttr"/>
    </xs:complexType>
  </xs:element>
  <!-- analogous to JATS mixed-citation[@citation-type='standard'] or equivalent -->
  <xs:element name="std">
    <xs:complexType mixed="true">
      <xs:group ref="oscal:mix"/>
      <xs:attribute name="href" type="xs:anyURI"/>
    </xs:complexType>
  </xs:element>
  <!-- analogous to JATS mixed-citation -->
  <xs:element name="citation">
    <xs:complexType mixed="true">
      <xs:group ref="oscal:mix"/>
      <xs:attribute name="href" type="xs:anyURI"/>
    </xs:complexType>
  </xs:element>
  <!-- We can map more html in if/as needed -->
  <xs:element name="p">
    <xs:complexType mixed="true">
      <xs:group ref="oscal:whatnot"/>
      <xs:attributeGroup ref="oscal:idAttr"/>
      <xs:attributeGroup ref="oscal:typeAttr"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="pre">
    <xs:complexType mixed="true">
      <xs:group ref="oscal:mix"/>
      <xs:attributeGroup ref="oscal:idAttr"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="ol">
    <xs:complexType>
      <xs:sequence>
        <xs:element maxOccurs="unbounded" ref="oscal:li"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="li">
    <xs:complexType mixed="true">
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:group ref="oscal:whatnot"/>
        <xs:element ref="oscal:ol"/>
        <xs:element ref="oscal:ul"/>
      </xs:choice>
      <xs:attributeGroup ref="oscal:idAttr"/>
      <xs:attributeGroup ref="oscal:typeAttr"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="ul">
    <xs:complexType>
      <xs:sequence>
        <xs:element maxOccurs="unbounded" ref="oscal:li"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <!-- whatnot includes 'semantical' elements along with the inline mix -->
  <xs:group name="whatnot">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="oscal:semantical"/>
        <xs:group ref="oscal:mix"/>
      </xs:choice>
    </xs:sequence>
  </xs:group>
  <xs:group name="mix">
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="oscal:inlines"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="inlines" abstract="true"/>
  <xs:element name="em" substitutionGroup="oscal:inlines">
    <xs:complexType mixed="true">
      <xs:group ref="oscal:mix"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="i" substitutionGroup="oscal:inlines">
    <xs:complexType mixed="true">
      <xs:group ref="oscal:mix"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="b" substitutionGroup="oscal:inlines">
    <xs:complexType mixed="true">
      <xs:group ref="oscal:mix"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="xref" substitutionGroup="oscal:inlines">
    <xs:complexType mixed="true">
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="oscal:q"/>
        <xs:element ref="oscal:code"/>
        <xs:element name="em" type="xs:string"/>
      </xs:choice>
      <xs:attribute name="href"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="q" substitutionGroup="oscal:inlines" type="xs:string"/>
  <!-- A bit of code (perhaps capable of evaluation in the correct context) -->
  <xs:element name="code" substitutionGroup="oscal:inlines">
    <xs:complexType mixed="true">
      <xs:group ref="oscal:mix"/>
      <xs:attribute name="type"/>
    </xs:complexType>
  </xs:element>
  <!-- not html! -->
  <xs:element name="semantical" abstract="true"/>
  <!-- A placeholder status report typically with a cross-reference -->
  <xs:element name="withdrawn" substitutionGroup="oscal:semantical">
    <xs:complexType mixed="true">
      <xs:sequence>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="oscal:inlines"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <!-- A value to be assigned by responder, possibly via a param (parameter) or parameter declaration -->
  <xs:element name="assign" substitutionGroup="oscal:semantical">
    <xs:complexType mixed="true">
      <xs:group ref="oscal:mix"/>
      <xs:attributeGroup ref="oscal:paramAttr"/>
    </xs:complexType>
  </xs:element>
  <!-- A selection to be made by responder -->
  <xs:element name="select" substitutionGroup="oscal:semantical">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="oscal:choice"/>
      </xs:sequence>
      <xs:attributeGroup ref="oscal:paramAttr"/>
    </xs:complexType>
  </xs:element>
  <!--
    Within a selection, a choice
    unlike 'value', choice may have inline stuff as well as 'assign' elements
  -->
  <xs:element name="choice">
    <xs:complexType mixed="true">
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="oscal:assign"/>
        <xs:group ref="oscal:mix"/>
      </xs:choice>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="idAttr">
    <xs:attribute name="id" type="xs:ID"/>
  </xs:attributeGroup>
  <!-- collapsing 'names' and 'types' as classes, HTML-style -->
  <xs:attributeGroup name="nameAttr">
    <xs:attribute name="class"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="typeAttr">
    <xs:attribute name="class"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="contextAttr">
    <xs:attribute name="context" use="required"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="paramAttr">
    <xs:attribute name="use"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="relAttr">
    <xs:attribute name="rel"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="hrefAttr">
    <xs:attribute name="href" use="required"/>
  </xs:attributeGroup>
  <!-- nameAttr = attribute name { xsd:NCName } -->
  <!---->
  <xs:element name="profile">
    <xs:complexType>
      <xs:sequence>
        <xs:element maxOccurs="unbounded" ref="oscal:invoke"/>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="oscal:mod"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="invoke">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" ref="oscal:include"/>
        <xs:element minOccurs="0" ref="oscal:exclude"/>
      </xs:sequence>
      <xs:attributeGroup ref="oscal:hrefAttr"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="include">
    <xs:complexType>
      <xs:choice>
        <xs:element ref="oscal:all"/>
        <xs:choice maxOccurs="unbounded">
          <xs:element ref="oscal:call"/>
          <xs:element ref="oscal:filter"/>
        </xs:choice>
      </xs:choice>
    </xs:complexType>
  </xs:element>
  <!-- 'all' or 'filter' make sense for inclusions but not exclusions -->
  <xs:element name="exclude">
    <xs:complexType>
      <xs:sequence>
        <xs:element maxOccurs="unbounded" ref="oscal:call"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="mod">
    <xs:complexType>
      <xs:attributeGroup ref="oscal:contextAttr"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="all">
    <xs:complexType/>
  </xs:element>
  <xs:element name="call">
    <xs:complexType mixed="true">
      <xs:attribute name="key" use="required"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="filter">
    <xs:complexType mixed="true">
      <xs:attribute name="key" use="required"/>
    </xs:complexType>
  </xs:element>
</xs:schema>
