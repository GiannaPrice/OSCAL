
x merge 'implementation' sections from 800-53A (PDF!) into draft control
o pull in more data from PDFs e.g. in 800-53 control enhancements
  Maybe do all of section AC (account controls)
o "Media Protection" section
  x Review shows there are discrepancies btw published PDF/Word and 800-53A XML,
    but also doesn't readily show anything that doesn't fit in OSCAL
    (missing numbering is missing; more detail on enhancements is given)

x xrefs and linking
  We are linking using a simple web-friendly notation. An href is a URL,
  adopting the # notation for internal (id) references.
  Note that @id is subject to rewrite by an application! so a robust
    linking mechanism under OSCAL would rely on controlled properties
    not (solely) on href plus they could be cross-checked against each other
    (binding+lock mechanism for linking)
  
x induction of implicit cross-references from SP800-53?
  e.g. inside supplemental guidance

x Implement parameters
   w/ parameter declarations?

x Define an ID assignment protocol and add IDs (to samples so far)?
    o implement as refactoring XSLT?
      taking numbering format as runtime parameter?!

o assignment/parameter support
  Implement 'assign' checking as Schematron (specific to catalog / control types)
  checks against normative versions in the background!?
Implement 'select' checking as detecting any select without selected/
  select/selected/choice
  select/available/choice

x 'preamble' section including declarations
    x control-spec (describing the structure of a control)
    x param-spec (naming permissible/recognized parameters)
    o authority (referencing external authorities / sources)

LAYERED VALIDATION MODEL
  0. element grammar
  1. OSCAL constraints (what makes a control catalog in OSCAL terms) - DON'T NEED?
  2. OSCAL profile constraints (OSCAL declarations)
  3. locally implemented extensions and customizations
  4. implicit/runtime/'culture' constraints (implementation-level)
  
TRANSFORMATIONS
  1. Selecting or filtering controls
  2. Expanding/resolving assignments
 
Define mapping format in OSCAL?
   e.g. a document that maps several catalog types over into OSCAL
   w/ tools for comparison

Implement OSCAL audit?
  producing a diff/compare btw a profile and its catalog showing all mods
  based on a simple diff btw processing results and catalog :-)

Expand filter rewrites all assign or select elements with their inherited param values?

Runtime declarations?
  x parameter value assignments
  o semantic associations / merge-map?
    (e.g. formal mappings between control properties)

NEXT UP July 2017
X collapse @role and @type to @class and revise tools
    including implementation of declarations/(prop|stmt|param)/singleton
  x did everything but implementing singleton declaration
  o but - stress test (unit test?) validations
      write up specs
o documentation - 
  o sp800-53 mapping
  o tag library
  o declarations model
o COBIT survey and analysis (write a log)

Profiles take different forms
  One of them is an "active profile in use" as it were, in a documented "OSCAL application"
    Tailoring for a single organization
  Another is "secondary (derived) catalog
    Tailoring (profiling) for an industry, domain, or application space
    Extending a base catalog
    Mapping and reconciling prior catalogs into new catalogs

CONTESTABLE DESIGN NOTES

Every profile is based on a catalog or multiple catalogs. A catalog is indeed (in one respect) nothing more than a "standalone" profile, that is, a profile that makes reference to no catalog but itself. We distinguish a catalog from a profile in use mainly because we hope we don't have to start from scratch; we generally base our work on earlier work or at least make reference to it - hence we are less interested in making a new catalog from scratch, than in creating a profile of (documenting a relation with) a catalog provided as a reference. Nonetheless, catalogs and profiles are made from the same stuff: the difference is in how we are using it.

We expect to have standard catalogs, so we don't have to produce them from scratch -- whereas we also expect we need to be able to do our own thing, hence the need for profiling.

With respect to content models, catalogs and profiles are isomorphic except wrt the presence of element 'authority'. One way to produce a profile (a 'null' profile ready for editing) of a given catalog, is to rename 'catalog' to 'profile' and add 'authority' pointing to the original catalog. (There are better ways to do this but it works.)

x Also declarations of properties/statements on groups (again by type)

modeling 'selections' via XML containment <select><alternative></></>

What sorts of things do we need to validate at the level of a control?
  Properties and statements that (may|must) appear
  Lexical form of properties
    x enumerated list
    x regex
    x numbering semantics (xsl:number?)
         value/inherit, value/number as dynamic substitution values
    * referential integrity (co-occurrence constraints)
      e.g. if in section "Access Control" then ID must start 'AC' ...

x XSLT to rip catalog declarations from a catalog
x oXygen Author CSS
  pull-downs for properties and statement types inside various controls (e.g.)

oXygen macros, boilerplate and auto-insert
  e.g. parameter names by reference to declarations

x remove sequence, clause, control-group properties (or anything so redundant)

o add xsd-type for declaration i.e. <xsd-type>decimal</xsd:type> validates $x castable as xs:decimal?

o Question re: implementations
  Our prototype is implemented on an XML stack in oXygen but OSCAL must be platform independent
  (We can also foresee developing on an XML stack off of oXygen, of course.
   XQuery/XForms comes to mind ...)
  So ... what other platforms / stacks can we be looking at?
    Python ... Ruby ... who do we have?
   
o consider the mapping to unify 800-53 and ISO 27002?
    issues:
      hierarchical alignment?
        (tool: head to head hierarchical comparison of catalogs / profiles
o       "Profile sketch" XSLT that produces hierarchical analysis in XML and SVG)
o       Mapping of controls w/ their properties and statements (easy to see in declarations)

XSLT template that for any control, returns its control context i.e. the hierarchy of controls
  and groups it appears in/with.

o prototype profiling mechanism
     Assume operator has a list of controls to include
        (including control enhancements or subcontrols, with containing controls)
     Also demo producing a profile by selection/filtering (e.g. baseline-impact)

x For Dave - group is good but should we permit control/control (eg 800-53A)
    no - now we have control/enhancement

o remodel control//control as control/subcontrol
o remove group from control
'title' not permitted as @role?
o rename 'desc' to stmt?

High level issues
  Setting names of elements and attributes
  Defining when a new schema must be layered over
    (e.g. new element types for privileged statements)
    also control points for that layering (in both RNG and XSD versions)

Write a simple narrative describing use of OSCAL

OSCAL is a world of controls, which cluster together in groups and within other ('higher level') controls. Controls come in different types but they all have the same basic form. They probably have titles and almost certainly have some normative language, called the "description" of the control (or sometimes just the "control"). Additionally they have one or more *properties* and *statements*, which provide structured information associated with the control. Exactly which properties and statements are present or available for a control, will depend on the particular control and the control type.

Properties are best thought of as name-value pairs. assigned to a control. So for example a control may have a property 'RATING' (or 'rating') that assigns a nominal rating to a control, permitting controls in a set to be sorted and filtered by rating. The "rating" of any control will be a single value (as this is a property), a string albeit sometimes embellished a little (parameters are described below).

Statements, in contrast, are best thought of as chunks or globs or hunks of prose, of arbitrary length. (Special-purpose statements may be short but some controls use statements to help keep the description short, i.e. for 'spillover'.) They may have internal structure, or they may be simply soup or piles of paragraphs and lists. (OSCAL borrows from HTML to keep the markup inside statements familiar.) Like properties, they might be enhanced (parameters again) in certain ways, but they will generally be fairly free form.

The 'description' of a control might indeed be considered a special or privileged kind of statement, even as its title is a kind of property. For the most part, however, OSCAL permits catalogs and profiles to define their own properties, property values, and statements, for whatever purposes they might need.

RULES OF CLASS ASSIGNMENT (TBD)

All properties and statements are assigned "roles", which must be distinctive within the control. That is, if a control has a property whose role is to be the "number", no other property or statement may be assigned that role. (To the same control. Other controls may have their own numbers especially if they are the same type as this one.) This means there is always a one-to-one relationship between (any given) property values, and the controls they describe -- a constraint that simplifies queries for controls, since we can know ahead of time that any control can have only a single 'name' or 'number' or 'blodget'. (If we have cases where we need many-to-many key relations, in OSCAL, we will do that not with properties or statements, but subcontrols.)

In OSCAL, the 'role' is expressed as a *controlled class*, which is to say, a value on the 'class' attribute. Not every value of class need be a controlled class; as in HTML, it is always possible (if not always a good idea) to overload class with more than one expressed value.
 
The "tailoring" or adaptation of controls generally entails adding or overwriting statements and properties given in control catalogs, as well as combining controls (with properties providing links to base controls, etc.) into new controls and control sets.

Parameters

Escape hatch: 'wait list' statements (i.e. no assigned role)

Control enhancements (subcontrols)

Declarations

Adaptability

The rules that define control types can be changed, and new control types can be introduced. Organizations can share control types and share information defined and described using them - that is, as "controls".

(It should be noted in passing that these are digital data objects or data instances, not actual "controls" in the world -- something ineffable, which the documentation of a control can only represent. But metaphysics and epistemology are not in scope here.)

Interchangeability

OSCAL is an entirely independent semantic 'stack' intended to promote interchange of a particular kind (or pattern) of information, a "control set". As such it can be mapped cleanly to NISO JATS, NLM BITS, NISO STS, DITA, or any other format.

x rnc for linking element
x merge 800-53A enhancements into 800-53 controls
x renamed enhancement to 'subcontrol'
x renamed enhancement/enhancement to 'feature'
x update and validate three pathways


x look at COBIT semantics issues (are they addressed by 'feature'?)
  ... so far yes ...
 o XSLT to convert input/output feature prop[@class=('to','from')] into links
   o similarly introduce link elements into IT goals
   o similarly upconvert Activities
      
o write XSLT to produce RACI chart for (all of) COBIT 5
  o plus profile showing just one role assigned ...


o prototype catalog profiling mechanism
  examples: the three baselines of SP800-53; COBIT by RACI role

Schema maintenance model
  Finish OSCAL tag library
  Convert RNC to RNG
  Convert RNG+OSCAL -> XSD
  Document all this on Github

Github Issues
  Namespace update

Define spec for content enhancement tranformation over SP800-53
  Infer links
  Infer assignments
  Add IDs

Same for other catalogs? such as 
Complete (OSCAL) mapping documents for three applications (flavors) so far

Regression testing (for schema, XSLT etc.)
  Requiring authoritative sample docs
    Go / no-go

look for ixsl:onchange mode (dynamic rendering)
add @datatype to 'param'
remove parameter declarations
remove param/@class (till later)

rough out profile functionality
  select controls by ID
  (then deselect controls by arbitrary criteria)
  implement paramesters and assignments (crude is okay)
  validation collection (selected controls) against source
    catalog to verify (existence) of control

links - validate internal cross-references
  validate required and singleton by @rel (relationship)

