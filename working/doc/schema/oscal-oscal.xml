<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="oscal-docs-html.xsl"?>
<?xml-stylesheet type="text/css" href="oscal.css" title="Straight" alternate="yes"?>
<?xml-stylesheet type="text/css" href="../../lib/CSS/oscal-author.css" title="Authoring" alternate="yes"?>
<?xml-model href="oscal-docs.sch" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<?xml-model href="../../lib/oscal-working.rnc" type="application/relax-ng-compact-syntax"?>
<catalog xmlns="http://scap.nist.gov/schema/oscal">
  <title>OSCAL: The Open Security Controls Assessment Language</title>
  <!--<declarations>
    <property context="element-description" class="tag">
          <required/>
      <identifier/>
          <regex>\i\c*</regex>
      <!-\- An XML name -\->
        </property>
    <property context="element-description" class="full_name"/>
    <feature context="element-description general-constraint" class="description">
      <required/>
    </feature>
    <part context="element-description" class="remarks"/>
    <property context="term-definition" class="term"/>
    <part context="term-definition" class="definition"/>
  </declarations>-->
  <section>
    <title>OSCAL namespace</title>
    <p>Conformant (valid) OSCAL documents will not contain elements not described in this document.
      While OSCAL may be mixed with other tag sets or extended, neither of these uses is described
      here: this document provides only basic information about the OSCAL <q>core</q>.</p>
    <p>The element population of an OSCAL document (set) may be determined by means of XPath
        <code>distinct-values(//*/node-name())</code>, or analogous query.</p>
    <p>For its XML names, OSCAL uses the namespace <a>XXX http://scap.nist.gov/schema/oscal XXX</a>.
      Commonly, this will be assigned to (unprefixed) names in an OSCAL document by default, and in
      this document, OSCAL elements (and attributes, presumed to be in no-namespace) are referenced
      without a prefix, <code>oscal:</code> or any other.</p>
    <p>By design, OSCAL looks a lot like HTML on the inside. Transformations to HTML, however, should
      always strip the OSCAL namespace to produce HTML in the appropriate namespace for the target
      application. (Or the target application could learn to consume OSCAL.) Only some parts of
      HTML, however, make their way into OSCAL, which is designed to address its own
      requirements.</p>
  </section>
  <section>
    <title>OSCAL organization</title>
    <p>OSCAL catalogs are built out of controls. Essentially, OSCAL is a lightweight and free-form
        <q>documentary</q> format, which includes semantic <q>islands</q> of structured information.
      These are semantic not only because they are addressable in principle, but more
      importantly because their organizations and values may be known before processing occurs, 
      at least with respect to certain operations and relations, and even (at the most general level)
      before operations are designed and deployed. OSCAL offers a yin to the yang of query and
      processing.</p>
    <p>At the broadest level, <q>control objects</q> in OSCAL include controls, subcontrols, parts
      of controls or subcontrols, and control groups. Each OSCAL application or application domain
      will determine for itself how these correspond to entities or <q>controls</q>, formal processes, procedures and so forth, within that domain.</p>
    <p>This organization is governed by an XML schema, which enforces containment constraints among
      these elements. In particular, the OSCAL schema declares elements for <code>group</code>,
        <code>control</code>, <code>subcontrol</code> and <code>part</code>. According to its rules,
      either controls or groups may appear within groups (that is, groups may be nested or may
      contain controls), while subcontrols may only appear within controls. Either controls or
      subcontrols may be partitioned (may contain parts), and parts may contain their own parts.
      While this design centers around controls and subcontrols, by means of the use of groups and
      parts, OSCAL can support organizations of controls and their components with arbitrary
      granularity -- as any of these objects may be used consistently to carry regular sets of
      properties, with names and value spaces that may be known in advance or discovered
      dynamically.</p>
  </section>
  <section>
    <title>Interoperability with other data formats</title>
    <p>OSCAL should map easily and straightforwardly to any generic XML or tag-based markup language
      including HTML, Markdown and its variants, NISO JATS, DITA, etc. Additionally, OSCAL
      documents may be taken as <q>warrants for inference</q> for serialization of linked data
      objects or other application binding formats including JSON.</p>
    <p>Because OSCAL is designed to carry richer and denser semantics than most markup languages as used, however, automated conversion into OSCAL from any of these formats (or at any rate, into a process-oriented and optimized OSCAL) is likely to require tuning or
      customization per instance - that is, each one will be a one-off conversion.</p>
  </section>
  <group>
    <title>Controls and control components</title>
    <p>The foundations of OSCAL are in control objects, such as controls and subcontrols, and their
      components, including both formal components (described here) and relatively uncontrolled or
      free-form contents (described elsewhere as <a href="oscal-oscal.xml#prose">prose</a>).</p>
    <control class="element-description">
      <prop class="tag">catalog</prop>
      <prop class="full_name">Catalog</prop>
      <part class="description">
        <p>Top-level element for a (canonical) control catalog</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">collection</prop>
      <prop class="full_name">Collection</prop>
      <part class="description">
        <p>Top-level element for a set of controls, not considered to be a catalog</p>
      </part>
      <part class="remarks">
        <p>Most often, a collection element will be used for a set of controls derived from one or
          more control catalogs (such as a profile, baseline, or overlay), which do not themselves
          serve as a catalog. However, collections may contain everything that catalogs may contain, 
          and OSCAL does not prohibit their use as (source or interim) catalogs for profiling, 
          although an individual application might.</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">control</prop>
      <prop class="full_name">Control</prop>
      <part class="description">
        <p>A structured information object representing a security control</p>
      </part>
      <part class="remarks">
        <p>Controls may be grouped using <code>group</code>, and controls may be partitioned using
          either (formally) <code>subcontrol</code> or (informally) <code>part</code>.</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">subcontrol</prop>
      <prop class="full_name">Control extension</prop>
      <part class="description">
        <p>An associated control within a control</p>
      </part>
      <part class="remarks">
        <p>A nominal subcontrol or <q>control extension</q> permits catalogs to offer access to
          structured control objects within controls. Further levels down can be achieved using
            <code>part</code> (both controls and subcontrols may be partitioned), which may contain
          their own parts; however, knowing in advance which <q>controls</q> and <q>subcontrols</q>
          are especially significant is helpful.</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">prop</prop>
      <prop class="full_name">Property</prop>
      <part class="description">
        <p>A value with a name, attributed to the containing control, subcontrol, part, or group</p>
      </part>
      <part class="remarks">
        <p>The notation used by a property is up to an application; otherwise, properties are
          distinguished in OSCAL by not permitting inline markup of any kind. They are
          expected to be simple scalar values or to use machine-readable/parseable
          notation (not XML), as defined by and for an application.</p>
        <p>The lexical composition of properties may be constrained by declarations including
          matching to regular expressions or declaring known datatype notations (tbd).</p>
        <p>Because properties are often used as selectors or identifiers for OSCAL operations,
          their values can be expected frequently to be flattened (markup stripped) and normalized
          (e.g., with respect to whitespace) in use; however this is application defined.</p>
        <p>For singletons (that is, the only element among siblings with its <code>@class</code>),
          properties are especially useful as proxies (unique identifiers) for their controls, such
          that controls may be returned one for one on queries for properties (name and value). The
          robustness of such queries can be ensured by appropriate property declarations (as
          singletons and as identifiers); cf <code>property</code> in the declarations model (which
          also supports other constraints over property values).</p>
        <p>Properties permit the deployment and management of arbitrary controlled values, with and
          among control objects (controls and parts and extensions), for any purpose useful to an
          application or implementation of those controls. Typically and routinely, properties will
          be used to sort, select, order, and arrange controls or relate them to one another or to
          class hierarchies, taxonomies, or external authorities.</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">param</prop>
      <prop class="full_name">Parameter</prop>
      <part class="description">
        <p>A parameter setting, to be propagated to points of insertion</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">part</prop>
      <prop class="full_name">Part</prop>
      <part class="description">
        <p>A component or partition in a control, subcontrol, or part</p>
      </part>
      <part class="remarks">
        <p>Like properties (<code>prop</code>) and parameters (<code>param</code>), parts can be
          distinguished from other elements within their controls by their assigned
            <code>@class</code>, such that they may be subjected to <q>declarations logic</q> using
          these values as bindings (and thereby getting open-ended extensibility).</p>
        <p>An assigned class may frequently provide for a header in display, such that
            <code>part[@class='objectives']</code> is displayed under a header <em>Objectives</em>,
          etc. Unlike groups, controls, or subcontrols, however, they may not have <code>title</code>
          element children (they are not <q>first class objects</q> in this sense). Thus, in OSCAL
          if the components of your controls have their own titles, they are something else; to
          accommodate data like this, consider using a property (e.g.,
            <code>prop[@class='part-title']</code> as an escape hatch.</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">link</prop>
      <prop class="full_name">Link</prop>
      <part class="description">
        <p>A line or paragraph with a hypertext link</p>
      </part>
      <part class="remarks">
        <p>Works like an HTML anchor (<code>a</code>) except this is a line-oriented (block)
          element.</p>
      </part>
      
    </control>
  </group>
  <group>
    <title>Functional elements</title>
    <p>Functional elements appear inside control content to provide <q>hooks</q> to OSCAL
      processors for retrievability, manipulation (including mapping and transformation), and
      semantic traversal.</p>
    <control class="element-description">
      <prop class="tag">insert</prop>
      <prop class="full_name">Parameter insertion</prop>
      <part class="description">
        <p>A <q>call</q> (reference) to a parameter for dynamic content transclusion</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">withdrawn</prop>
      <prop class="full_name">Withdrawn</prop>
      <part class="description">
        <p>Indicates that a containing control or subcontrol is no longer applicable</p>
      </part>
      <part class="remarks">
        <p>Used to mark a control or subcontrol included in a catalog as a placeholder, to maintain
          its semantic integrity even in obsolescence. Links should be provided to superseding
          controls or components.</p>
        <p>The functionality provided by this element might better be offered by a property or some
          other controlled value, at which point it may be removed; it is included to support (some)
          legacy content.</p>
      </part>
    </control>
    <!--<control class="element-description"><prop class="tag">select</prop><prop class="full_name">Selection</prop><part class="description"><p>A selection requiring designation via parameter (tbd)</p></part></control>-->
    <!--<control class="element-description"><prop class="tag">choice</prop><prop class="full_name">Choice</prop><part class="description"><p>A choice of values, to be designated via parameter (tbd)</p></part></control>-->
  </group>
  <group>
    <title>Declarations elements</title>
    <p>By declaring constraints on control components, such as properties (<code>prop</code>), parts
        (<code>part</code>) and links (<code>link</code>) within controls and subcontrols,
      applications and operators can validate the regularity and composition of available controls.
      By documenting constraints that are enforceable at need, declarations also serve as an
      implicit <q>semantic contract</q> between a control catalog (or set of controls valid to a set
      of OSCAL declarations).</p>
    <p>In this way, the OSCAL declarations mechanism provides for a kind of <q>on the fly
        supertyping</q> of control objects, by restriction (constraint) of the core OSCAL language.
      The extent and degree to which declarations are used to impose order on controls is up to the
      application and its methods. By no means are declarations necessary; rather, they serve as an
      aid in modeling and in communicating expectations.</p>
    <p>OSCAL declarations are enforced by a Schematron; the core schema stipulates their model but
      does not enforce any of the constraints so declared. Developers should take note that these
      constraints are all readily testable in XPath.</p>
    <control class="element-description">
      <prop class="tag">declarations</prop>
      <prop class="full_name">Declarations</prop>
      <part class="description">
        <p>For extra-schema validation of control components within controls</p>
      </part>
      <part class="remarks">
        <p>The OSCAL validation model supports not only validation against a formal schema
          (describing elements, attributes, and their permitted contents, described generally and
          generically), but also against a set of declarations provided specifically for the catalog
          or catalog type within which they appear. Constraints described in these declarations, and
          bound via assignments of <code>@class</code> (for control components) and
            <code>@context</code> (indicating control, subcontrol or part wherein the components may
          appear), enable automated checking for consistency of controls, subcontrols and their
          parts, specific to the types or kinds of control items that appear within a particular
          catalog or control collection.</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">declare-property</prop>
      <prop class="full_name">Property declaration</prop>
      <part class="description">
      <p>Constraints applicable to a class or classes of <code>p</code> elements within a control
        object</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">declare-p</prop>
      <prop class="full_name">Paragraph declaration</prop>
      <part class="description">
        <p>Indicates constraints to be enforced on paragraphs in context</p>
      </part>
      
    </control>
    <control class="element-description">
      <prop class="tag">declare-part</prop>
      <prop class="full_name">Part declaration</prop>
      <part class="description">
        <p>Indicates constraints to be imposed on parts in context</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">declare-link</prop>
      <prop class="full_name">Link declaration</prop>
      <part class="description">
        <p>Indicates constraints to be imposed on links in context</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">singleton</prop>
      <prop class="full_name">Singleton constraint</prop>
      <part class="description">
        <p>The declared component may occur only once in its context</p>
      </part>
      <part class="remarks">
        <p>When this element is present in the declaration of an OSCAL control component, the
          component (<code>prop</code>, <code>param</code>, <code>part</code>) must be the only
          component of that class given in its (<code>group</code>, <code>control</code>,
            <code>subcontrol</code>, or <code>part</code>) context. In other words, no other element child of
          the same parent may have the same <code>@class</code> value (at the level of syntax) or
          be bound to the same component type (at the semantic level).</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">required</prop>
      <prop class="full_name">Requirement constraint</prop>
      <part class="description">
        <p>The declared component is required in its context</p>
      </part>
      <part class="remarks">
        <p>When this element is present in the declaration of an OSCAL control component, the
          component (<code>prop</code>, <code>param</code>, <code>stmt</code>, or <code>feat</code>)
          is required to appear, at least once, in its context.</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">identifier</prop>
      <prop class="full_name">Identifier constraint</prop>
      <part class="description">
        <p>The declared component has a value unique within the document, among components of the
          same type</p>
      </part>
      <part class="remarks">
        <p>This constraint is generally only used for properties to be used as identifiers for their
          control object (control, subcontrol, or part). Guaranteeing their uniqueness means that
          these values can be used to effect one-to-one retrieval or reference to the objects to
          which they are assigned.</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">regex</prop>
      <prop class="full_name">Regular expression constraint</prop>
      <part class="description">
        <p>Indicates that the value of a property (<code>prop</code>) or parameter
            (<code>param</code>) must match the given regular expression</p>
      </part>
      <part class="remarks">
        <p>Matching against a regular expression is conducted on the normalized lexical value of the
          given parameter or property: that is, with leading and trailing whitespace stripped,
          interim whitespace (spaces, tabs, and line feeds) normalized to single spaces, and inline
          markup stripped.</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">value</prop>
      <prop class="full_name">Value constraint</prop>
      <part class="description">
        <p>Indicates a permissible value for a parameter or property</p>
      </part>
      <part class="remarks">
        <p>In a declaration, <code>value</code> will commonly be given in groups, indicating a set
          of enumerated permissible values (i.e., for an element to be valid to a value constraint,
          it must equal one of the given values).</p>
        <p>In a parameter, a value represents a value assignment to the parameter, overriding any
          value given at the point of insertion. When parameters are provided in OSCAL profiles,
          their values will override any values assigned <q>lower down the stack</q>.</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">autonum</prop>
      <prop class="full_name">Autonumbered (generated) value</prop>
      <part class="description">
        <p>Generates a formatted numeric value based on the position of a control object among its
          siblings, the text contents providing a template for the numbering format (arabic,
          alphabetic, roman, etc)</p>
      </part>
      <part class="remarks">
        <p>The text contents of <code>autonum</code> (not the value of any attribute), will be taken
          by the processor to be a formatting code. The format should follow the spec for <a
            href="https://www.w3.org/TR/xslt-30/#element-number">XSLT
              <code>xsl:number/@format</code></a>. For example, if the value is <q>A.</q>, then
          numbering will appear in the sequence A., B., C., etc (as punctuated). Recognized formats
          include upper- and lower-case alphabetic numbering, arabic numbering, and upper- and
          lower-case roman numbering as described for XSLT.</p>
        <!--<p>The best way to understand the workings of this element is to see operational examples.</p>-->
      </part>
      
    </control>
    <control class="element-description">
      <prop class="tag">inherit</prop>
      <prop class="full_name">Inherited value</prop>
      <part class="description">
        <p>Indicates that a value or text within a value should be inherited from a property on a
          containing control object</p>
      </part>
      <part class="remarks">
        <p><code>inherit</code> is typically used to enforce hierarchical numbering within control
          objects. When given in a <code>value</code> in a declaration, <code>inherit</code>
          indicates that the value of a property, or a segment of its value, must be the same as a
          property (<code>prop</code>) higher in the containment hierarchy of a control object. That
          is, if a property with <code>@class='number'</code> is constrained with
            <code>value/inherit</code>, it must be the same as is assigned on the closest ancestor
            (<code>part</code>, <code>subcontrol</code>, <code>control</code>, or
          <code>group</code>) with the given property.</p>
        <p>Usually, <code>inherit</code> is used in conjunction with <code>autonum</code>. Using the
          two elements in combination, for example, the number (property) assigned to a subcontrol
          appearing inside a control numbered <q>A1</q> may be constrained to be <q>A1-a</q>,
            <q>A1-b</q>, etc., depending on the position of the subcontrol within the control.</p>
        <p>If a value must inherit from a property of a different class from the containing control
          object, <code>inherit/@from</code> can be used to indicate the applicable property (by its
          class). By default, <code>inherit</code> indicates a property value should match an
          ancestor's property with the same <code>@class</code> (the most usual case).</p>
        <!--<p>The best way to understand the workings of this element is to see operational examples.</p>-->
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">desc</prop>
      <prop class="full_name">Parameter description</prop>
      <part class="description">
        <p>Indicates and explains the purpose and use of a parameter</p>
      </part>
    </control>
    
  </group>
  <group>
    <title>Structural elements</title>
    <control class="element-description">
      <prop class="tag">section</prop>
      <prop class="full_name">Section</prop>
      <part class="description">
        <p>For partitioning a catalog, collection or section therein</p>
      </part>
      <part class="remarks">
        <p>Echoes HTML5 <code>section</code>. May contain controls (<code>control</code>) or groups
          of controls (<code>group</code>).</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">group</prop>
      <prop class="full_name">Group</prop>
      <part class="description">
        <p>Related controls or groups (of controls or groups)</p>
      </part>
      <part class="remarks">
        <p>In addition to controls or groups, groups may be titled and may have their own
          properties, statements, parameter settings and references, subject to declaration. In this
          respect they are like controls, subcontrols or parts, but their properties apply to the
          entire group and must be acquired in processing via inheritance.</p>
        <p>Unlike sections (<code>section</code> elements), groups may not contain arbitrary prose
          (paragraphs and lists). They may, however, contain statements (stmt), which may be untyped
          (no <code>@class</code>) and therefore unconstrained by declarations.</p>
      </part>
      
    </control>
    <control class="element-description">
      <prop class="tag">title</prop>
      <prop class="full_name">Title</prop>
      <part class="description">
        <p>A fallback for display and navigation, exclusive of more specific properties</p>
      </part>
      
    </control>
    <control class="element-description">
      <prop class="tag">references</prop>
      <prop class="full_name">References</prop>
      <part class="description">
        <p>A group of reference descriptions</p>
      </part>
      
    </control>
    <control class="element-description">
      <prop class="tag">ref</prop>
      <prop class="full_name">Reference</prop>
      <part class="description">
        <p>A reference, with one or more citations to standards, related documents or other
          resources</p>
      </part>
      
    </control>
    <control class="element-description">
      <prop class="tag">std</prop>
      <prop class="full_name">Standard</prop>
      <part class="description">
        <p>Citation of a formal published standard</p>
      </part>
      <part class="remarks">
        <p>Echoes the NISO JATS (and NISO STS) <code>std</code> element</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">citation</prop>
      <prop class="full_name">Citation</prop>
      <part class="description">
        <p>Citation of a resource</p>
      </part>
      <part class="remarks">
        <p>Echoes the NISO JATS (and NISO STS) <code>mixed-citation</code> element.</p>
        <p>For references to standards, <code>std</code> (qv) may be preferred.</p>
      </part>
    </control>
  </group>
  <group id="prose">
    <title>Prose</title>
    <p>Prose may ordinarily appear anywhere in a control, subcontrol, or part, or at a higher level.
      Prose elements echo HTML semantics, although they provide only a deliberately and specifically
      narrow subset of HTML element types.</p>
    <p>Prose elements may be constrained by declarations like other control components, although
      this may not often be as useful as imposing constraints over properties and parts. Frequently,
      a part organization will be used to assign prose to specific known <q>sections</q> or
        <q>components</q> of a control (modeled as <code>part</code> or
      <code>subcontrol</code>).</p>
    <control class="element-description">
      <prop class="tag">p</prop>
      <prop class="full_name">Paragraph</prop>
      <part class="description">
        <p>Paragraph or paragraph fragment</p>
      </part>
      <part class="remarks">
        <p>This element echoes HTML <code>p</code>; as in HTML, it is not limited to indicating
          complete or discrete (compositional or logical) paragraphs, but can be used for any text
          set off on its own line.</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">pre</prop>
      <prop class="full_name">Preformatted text</prop>
      <part class="description">
        <p>Retains whitespace in display</p>
      </part>
      <part class="remarks">
        <p>Echoes HTML <code>pre</code>.</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">ol</prop>
      <prop class="full_name">Ordered List</prop>
      <part class="description">
        <p>Appears with numbering in ordinal position</p>
      </part>
      <part class="remarks">
        <p>Although this echoes HTML <code>ol</code>, renditional aspects of this element are not
          offered by OSCAL. How lists are to be numbered is left to implementations; it
          is likely that specific control catalogs will have their own schemes.</p>
        <p>At present there is no support for <q>continued lists</q>, as we have not seen any in
          documents in scope for analysis.</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">ul</prop>
      <prop class="full_name">Unordered list</prop>
      <part class="description">
        <p>A series of items kept in order but without indicators of sequence; likely bulleted</p>
      </part>
      <part class="remarks">
        <p>As in HTML, <q>unordered</q> does not indicate that the order of contained list items is
          not respected, only that they are not displayed with any notation indicating their order:
          that is, bullets, not numbers.</p>
        <p>Note that when sequences or lists appear, it may be as common in OSCAL to list (and
          control) them as sequences of properties or paragraphs, perhaps grouped in parts or
          subcontrols. This is very much a display element, convenient when what we have is really
          prose, not highly organized or <q>semantic</q>.</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">li</prop>
      <prop class="full_name">List item</prop>
      <part class="description">
        <p>An item demarcated with a bullet or numerator</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">em</prop>
      <prop class="full_name">Emphasis</prop>
      <part class="description">
        <p>Rhetorical emphasis as typically indicated by a font shift</p>
      </part>
      <part class="remarks">
        <p>In display, this element can be expected to <q>toggle</q>, i.e. provide for italics when
          appearing within roman text, but roman when appearing within italic text.</p>
        <p>Particular semantics (indicating types of emphasis for finer resolution in display or
          retrieval) may be provided via <code>@class</code>.</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">i</prop>
      <prop class="full_name">Italics</prop>
      <part class="description">
        <p>Typographical shift to italics</p>
      </part>
      <part class="remarks">
        <p>An implementation may toggle, i.e., display contents using a roman face when the
          surrounding text is already italic.</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">b</prop>
      <prop class="full_name">Bold</prop>
      <part class="description">
        <p>Typographical shift to bold</p>
      </part>
      <part class="remarks">
        <p>In display, when the surrounding text is already bold, an implementation may indicate
            <q>bold</q> by means of double-bold or some other typographical distinction.</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">a</prop>
      <prop class="full_name">Anchor</prop>
      <part class="description">
        <p>An HTML-style anchor (inline linking element)</p>
      </part>
      <part class="remarks">
        <p>As in HTML, the link target is indicated by <code>@href</code>, with a '#' prefix for an
          internal cross-reference matching an <code>@id</code> elsewhere in the document.</p>
        <p>Anchors without <code>@href</code> are not invalid to the OSCAL schema (base validation),
          but may be reported by a Schematron. An application may promote the contents of an
            <code>a</code> element, when a valid URI, to serve as the link target if
            <code>@href</code> is missing or not a URI.</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">q</prop>
      <prop class="full_name">Quoted text</prop>
      <part class="description">
        <p>An inline segment to appear within quotation marks</p>
      </part>
      <part class="remarks">
        <p>For practical purposes, this is a cosmetic element with no special semantics other than
          to provide quotation marks in display.</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">code</prop>
      <prop class="full_name">Code</prop>
      <part class="description">
        <p>Inline code</p>
      </part>
      <part class="remarks">
        <p>Strictly, this element should identify formal code or code fragments.</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">sup</prop>
      <prop class="full_name">Superscript</prop>
      <part class="description">
        <p>Superscripted text</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">sub</prop>
      <prop class="full_name">Subscript</prop>
      <part class="description">
        <p>Subscripted text</p>
      </part>
    </control>
    <control class="element-description">
      <prop class="tag">span</prop>
      <prop class="full_name">Span</prop>
      <part class="description">
        <p>Generic inline container</p>
      </part>
      <part class="remarks">
        <p>As in HTML, an escape hatch for arbitrary (inline) semantic (or other) tagging.</p>
      </part>
    </control>
  </group>
  <group>
    <title>Structural constraints</title>
    <part>
      <p>Over and above what can be validated with a grammar (in Level 0), there is a small set of
        constraints governing usage. Validations enforcing them can be implemented via Schematron or
        another process capable of static analysis of the data.</p>
    </part>
    <control class="general-constraint">
      <title>Order of items inside controls</title>
      <part class="description">
        <p>Within a control, properties, parts, and parameters may occur in any order.</p>
        <p>This specification does not govern how or whether an implementation may respect the order
          of properties and statements given within a control type. Among properties, formal parts,
          and parameters within a control, cardinality constraints (where enforced) can help ensure
          a canonical order. An order may be imposed locally by an application (for example, using a
          schema that requires all properties to appear before all parts), but this is for its
          convenience, not because an order is mandated.</p>
      </part>
    </control>
  </group>
  <!-- commented this out as it needs reworking … <section><title>Customization layers</title><p>Like many tag languages and machine-readable syntaxes, OSCAL is intended to be extended and customized. Unlike most other formats, however, OSCAL's primary extension mechanism does not require schema extension, but is done within OSCAL itself, by introducing constraints over and above the basic tagging language in the form of declarations that apply to elements in the particular OSCAL instance or family.</p><p>OSCAL's validation model consists of several layers. At base is schema validation, which ensures that all tags in use are recognized as OSCAL tagging and that their arrangement in the document (with regard to both structure and certain <q>semantic</q> relations) is consistent with regular usage of OSCAL. In a second layer, other relationships can be tested and rules enforced, over and above what a schema imposes. Implemented in Schematron or any technology with analogous capabilities, such a second layer is more flexible and configurable than the base layer.</p><p>In a third layer, an OSCAL document is validated to constraints it declares for itself (locally in its own declarations). (Call this a <q>consistency check</q> rather than validation, for clarity.) Such a validation may be useful to an OSCAL implementation, which can take advantage of contracts implicit in such validation to provide functionalities. OSCAL itself does not provide such functionality, but only the hooks – and the mechanism by which users and developers can easily create and manage new control types.</p></section>-->
</catalog>
